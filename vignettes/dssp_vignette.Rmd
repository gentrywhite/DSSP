---
title: "DSSP: Direct Sampling Spatial Prior"
author: "Gentry White"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{DSSP}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  \usepackage[utf8]{inputenc}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  error = TRUE,
  purl = FALSE,
  collapse = TRUE,
  comment = "#>"
)
```
## Introduction
This short vignette demonstrates the use of the functions DSSP() and DSSP.predict() to analyse spatial data.  The example here uses the Meuse River data set from the package 'sp'. First start by loading the library and data set 'meuse.all'. 

```{r}
library(DSSP)
library(sp)
library(gstat)
library(ggplot2)

data("meuse.all")
```
Next, set the coordinates for the data and extract the $X$ matrix of locations and the $Y$ the log of observed zinc concentrations,
```{r}
coordinates(meuse.all) = ~x+y

## Use same data in the TPS model

X<-scale(coordinates(meuse.all))
X.train<-X[1:155,]
Y<-scale(log(meuse.all$zinc))
Y.train<-Y[1:155]
X.pred<-X[156:164,]
```
note that data are scaled, this is typically good practice. 

Next, we select the number of samples to draw and invoke the function DSSP().

```{r}
N<-10000  ## number of samples to draw from the DSSP model

meuse.fit<-DSSP(N,X.train,Y.train,function(x) -2*log(1+x), pars=c(0.001,0.001),ncores=1)

ETA<-meuse.fit$eta
DELTA<-meuse.fit$delta
NU<-meuse.fit$nu

```
The function DSSP() takes as its argument $N$ the number of samples desired, $X$ the matrix of coordinate pairs indicating locations of the observed data $Y$, as well as a function specifying the prior density of $\eta$, the shape and rate parameters of the inverse-gamma prior for $\delta$, and $ncores$ the number of cores to use. The argument $ncores$ is an optional argument that is only effective if your version of R is configured to use OpenMP.  

##  Rescale NU to reflect the original units

center.y<-attr(y.train,"scaled:center")
scale.y<-attr(y.train,"scaled:scale")

yhat<-rowMeans(exp(NU*scale.y+center.y))

meuse$yhat<-yhat ## Model estimates of E(zinc concentration (ppm))

##  Now plot Parameter Estimates and ACF Plots
```{r, ,include=TRUE,fig.show='hold'}
library(ggplot2)
ggplot(data.frame(X=seq(0,1,len=10000),x=ETA,y=exp(-seq(0,1,len=10000))))+geom_density(aes(x=x))+
    labs(x=expression(eta),y="posterior density",title=expression("Posterior Density of "*eta))+
    theme(plot.title=element_text(hjust=0.5))#+    geom_line(aes(x=X,y=y))

ggplot(data.frame(X=seq(0,1,len=10000),x=DELTA,y=exp(-seq(0,1,len=10000))))+geom_density(aes(x=x))+
  labs(x=expression(delta),y="posterior density",title=expression("Posterior Density of "*delta))+
  theme(plot.title=element_text(hjust=0.5))#+    geom_line(aes(x=X,y=y))
```

```{r, fig.show='hold'}
eta_acf <- acf(ETA, plot = FALSE)
eta_acfdf <- with(eta_acf, data.frame(lag, acf))

ggplot(data = eta_acfdf, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0))+
  labs(x="Lag",y="ACF",title=expression("ACF for Samples from Posterior of "*eta))+
  theme(plot.title=element_text(hjust=0.5))

delta_acf <- acf(DELTA, plot = FALSE)
delta_acfdf <- with(delta_acf, data.frame(lag, acf))

ggplot(data = delta_acfdf, mapping = aes(x = lag, y = acf)) +
  geom_hline(aes(yintercept = 0)) +
  geom_segment(mapping = aes(xend = lag, yend = 0))+
  labs(x="Lag",y="ACF",title=expression("ACF for Samples from Posterior of "*delta))+
  theme(plot.title=element_text(hjust=0.5))
```

```{r, fig.show='hold'}
ggplot(data.frame(x=1:length(ETA),y=cumsum(ETA)/(1:length(ETA))))+
  geom_line(aes(x=x,y=y))+
  labs(x="sample",y=expression(eta),title=expression("Cumuulative Mean of Samples from Posterior of "*eta))+
  theme(plot.title=element_text(hjust=0.5))

ggplot(data.frame(x=1:length(DELTA),y=cumsum(DELTA)/(1:length(DELTA))))+
  geom_line(aes(x=x,y=y))+
  labs(x="sample",y=expression(eta),title=expression("Cumuulative Mean of Samples from Posterior of "*delta))+
  theme(plot.title=element_text(hjust=0.5))
```





##  Try predicting at new locations to see the differences

```{r}
Y.pred<-DSSP.predict(meuse.fit,X.pred)
```

##  Plot Results and compare the true values

```{r, ,include=TRUE,fig.show='hold'}
library(ggplot2)
pred.data<-data.frame(cbind(yhat,y.true=meuse.all$zinc[156:164]))

ggplot(pred.data,aes(x=yhat,y=y.true))+
    geom_point(size=3)+
    geom_abline(aes(intercept=0,slope=1))+
    labs(x="Predicted Values",y="True Values",title="Predicted vs. True Values")+
    xlim(min(pred.data),max(pred.data))+
    ylim(min(pred.data),max(pred.data))+
    theme(plot.title = element_text(hjust=0.5))
```

```{r, ,include=TRUE,fig.show='hold'}
ggplot(stack(as.data.frame(t(Y.pred))))+
    geom_boxplot(aes(x=ind,y=values))+
    geom_point(data=data.frame(Y.true=Y[156:164]),aes(x=1:9,y=Y.true),shape=4,size=3)+
    labs(x="",y="Y",title="Boxplot of Predicted Values of Y and True Values (X)")+
    theme(plot.title = element_text(hjust=0.5))
```


<!-- Vignettes are long form documentation commonly included in packages. Because they are part of the distribution of the package, they need to be as compact as possible. The `html_vignette` output type provides a custom style sheet (and tweaks some options) to ensure that the resulting html is as small as possible. The `html_vignette` format: -->

<!-- - Never uses retina figures -->
<!-- - Has a smaller default figure size -->
<!-- - Uses a custom CSS stylesheet instead of the default Twitter Bootstrap style -->

<!-- ## Vignette Info -->

<!-- Note the various macros within the `vignette` section of the metadata block above. These are required in order to instruct R how to build the vignette. Note that you should change the `title` field and the `\VignetteIndexEntry` to match the title of your vignette. -->

<!-- ## Styles -->

<!-- The `html_vignette` template includes a basic CSS theme. To override this theme you can specify your own CSS in the document metadata as follows: -->

<!--     output:  -->
<!--       rmarkdown::html_vignette: -->
<!--         css: mystyles.css -->

<!-- ## Figures -->

<!-- The figure sizes have been customised so that you can easily put two images side-by-side.  -->

<!-- ```{r, fig.show='hold'} -->
<!-- plot(1:10) -->
<!-- plot(10:1) -->
<!-- ``` -->

<!-- You can enable figure captions by `fig_caption: yes` in YAML: -->

<!--     output: -->
<!--       rmarkdown::html_vignette: -->
<!--         fig_caption: yes -->

<!-- Then you can use the chunk option `fig.cap = "Your figure caption."` in **knitr**. -->

<!-- ## More Examples -->

<!-- You can write math expressions, e.g. $Y = X\beta + \epsilon$, footnotes^[A footnote here.], and tables, e.g. using `knitr::kable()`. -->

<!-- ```{r, echo=FALSE, results='asis'} -->
<!-- knitr::kable(head(mtcars, 10)) -->
<!-- ``` -->

<!-- Also a quote using `>`: -->

<!-- > "He who gives up [code] safety for [code] speed deserves neither." -->
<!-- ([via](https://twitter.com/hadleywickham/status/504368538874703872)) -->
